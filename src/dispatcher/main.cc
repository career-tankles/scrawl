// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.


#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/transport/TBufferTransports.h>

#include <glog/logging.h>
#include <gflags/gflags.h>
#include <boost/shared_ptr.hpp>

#include <string>
#include <vector>
#include <signal.h>

#include "utils.h"
#include "ThriftClientWrapper.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

struct server_t
{
    std::string ip;
    unsigned short port;
};

int load_servers(std::string& addr_list, std::vector<server_t>& servers)
{
    std::vector<std::string> v;
    splitByChar(addr_list.c_str(), v, ';');
    for(int i=0; i<v.size(); i++) {
        std::string str = v[i];
        std::vector<std::string> v2;
        splitByChar(str.c_str(), v2, ':');
        assert(v2.size() == 2);

        server_t s;
        s.ip = v2[0];
        s.port = atoi(v2[1].c_str());
        assert(!s.ip.empty() && s.port>1000);
        servers.push_back(s);
    }
    return servers.size();
}


class SpiderWebServiceHandler : virtual public SpiderWebServiceIf {
 public:
  SpiderWebServiceHandler() {
    // Your initialization goes here
    send_num_ = 0;
    switch_client_num_ = 0;
  }
  SpiderWebServiceHandler(boost::shared_ptr<ThriftClientWrapper>& clients) 
    : clients_(clients)
  {
    // Your initialization goes here
    send_num_ = 0;
    switch_client_num_ = 0;
  }


  int32_t setConfig(const SiteConfig& site_cfg) {
    // Your implementation goes here
    printf("setConfig\n");
  }

  int32_t submit(const HttpRequest& rqst) {
    if(!client_ || send_num_++ >= switch_client_num_){
         client_ = clients_->client();
         if(!client_) {
             LOG(ERROR)<<"DISPATCHER no client exist";
             return -1;
         }
         send_num_ = 0;
     }

     int ret = client_->send(rqst.url, rqst.userdata);
     if( ret != 0){
         client_ = clients_->client();
         if(!client_) {
             LOG(ERROR)<<"DISPATCHER no client exist";
             return -1 ;
         }
     }
      
     return 0;
  }  
     
  int32_t submit_url(const std::string& url) {
    if(!client_ || send_num_++ >= switch_client_num_){
         client_ = clients_->client();
         if(!client_) {
             LOG(ERROR)<<"DISPATCHER no client exist";
             return -1;
         }
         send_num_ = 0;
     }

     int ret = client_->send(url);
     if( ret != 0){
         client_ = clients_->client();
         if(!client_) {
             LOG(ERROR)<<"DISPATCHER no client exist";
             return -1 ;
         }
     }
  }  

private:
    boost::shared_ptr<ThriftClientWrapper> clients_;
    boost::shared_ptr<ThriftClientInstance> client_;

    int send_num_;
    int switch_client_num_;

};

DEFINE_int32(SERVER_thrift_port, 9090, "");
DEFINE_int32(SERVER_thrift_threadnum, 10, "");
DEFINE_string(CLIENT_server_addr, "localhost:9090", "");

TThreadPoolServer* g_server = NULL;

static void sig_handler(const int sig) {
    LOG(INFO)<<"SIGINT or SIGTERM is catched.\nsystem is stoping\n";
    if(g_server) {
        g_server->stop();
    }
}

int main(int argc, char **argv) {
    google::ParseCommandLineFlags(&argc, &argv, true);
    // Initialize Google's logging library.
    FLAGS_logtostderr = 1;
    google::InitGoogleLogging(argv[0]);

    signal(SIGINT, sig_handler);   
    signal(SIGTERM, sig_handler);   

    std::vector<server_t> servers;   
    int ret = load_servers(FLAGS_CLIENT_server_addr, servers);
    assert(ret > 0 && "load_servers failed");

    boost::shared_ptr<ThriftClientWrapper> clients(new ThriftClientWrapper);
    for(int i=0; i<servers.size(); i++) {
        server_t& server = servers[i];
        ret = clients->connect(server.ip.c_str(), server.port);
        if(ret != 0) {
            LOG(INFO)<<"DISPATCHER connect to "<<server.ip<<":"<<server.port<<" failed!";
            continue;
        }
        LOG(INFO)<<"DISPATCHER connect to "<<server.ip<<":"<<server.port;
    }

    // thrift service 
    int port = FLAGS_SERVER_thrift_port;
    shared_ptr<SpiderWebServiceHandler> handler(new SpiderWebServiceHandler(clients));
    shared_ptr<TProcessor> processor(new SpiderWebServiceProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
 
    //TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    int workerCount = FLAGS_SERVER_thrift_threadnum;
    shared_ptr<ThreadManager> threadManager =
        ThreadManager::newSimpleThreadManager(workerCount);
    shared_ptr<PosixThreadFactory> threadFactory =
        shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();
    TThreadPoolServer server(processor,
                             serverTransport,
                             transportFactory,
                             protocolFactory,
                             threadManager);
  /*
    TThreadedServer server(processor,
                         serverTransport,
                         transportFactory,
                         protocolFactory);

  */
  
    g_server = &server;
    printf("Starting the server...\n");
    server.serve();
    printf("Done.\n");

    return 0;
}

